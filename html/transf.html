<html>
<head><title>Transformation</title></head>
<body bgcolor=white>
<a href="codegen.html"><img src="next.gif" border=0></a> <a href="traversal.html"><img src="previous.gif" border=0></a><br><br>
<font  face=helvetica size=-1>
<a href="index.html">HANDBOOK</a>
 / <a href="primer.html">GENTLE PRIMER</a>
 / <a href="glance.html">At a Glance</a>
 /<br><br>
</font>
<h1>Transformation</h1>

<p>
We now look at a more interesting algorithm that works on the abstract syntax.
We introduce the placeholder <tt> x</tt> and interpret an expression as a function
in <tt> x</tt>. Given such an expression <i>E</i>, we will compute an expression
<i>E'</i> that represents the derivative of the function.
<p>
We extend the abstract syntax by the alternative
<PRE>

   x
</PRE>

and add to the concrete syntax the rule
<PRE>


   'rule' expr3(-> x): "x"

</PRE>

<p>
The root clause now takes the form
<PRE>

'root' expression(-> X) deriv(X -> D) print(D)

</PRE>

<p>
The procedure <tt> deriv</tt> is then defined as follows
<PRE>

'action' deriv (Expr -> Expr)

'rule' deriv(mult (U,V) -> plus(mult(Ud,V), mult(U,Vd))):
   deriv(U -> Ud)
   deriv(V -> Vd)
'rule' deriv(div(U,V) -> div(minus(mult(Ud,V),mult(U,Vd)),mult(V,V))):
   deriv(U -> Ud)
   deriv(V -> Vd)
'rule' deriv(plus(U,V) -> plus(Ud, Vd)):
   deriv(U -> Ud)
   deriv(V -> Vd)
'rule' deriv(minus(U,V) -> minus(Ud, Vd)):
   deriv(U -> Ud)
   deriv(V -> Vd)
'rule' deriv(num(N) -> num(0))
'rule' deriv(x -> num(1))
</PRE>

<p>

<br><br>
</ul>
</ul>
</ul>
<a href="codegen.html"><img src="next.gif" border=0></a> <a href="traversal.html"><img src="previous.gif" border=0></a></body>
</html>
