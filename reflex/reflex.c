#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ( 1) %{ */
/* ( 2) YYSTYPE block */
/* ( 3) SETPOS block */
/* ( 4) LITBLOCK block */
/* ( 5) %} */
/* ( 6) LEXDEF block */
/* ( 7) %% */
/* ( 8) gen.lit */
/* ( 9) <token>.t for each <token> in gen.tkn */
/* (10) COMMENTS block */
/* (11) LAYOUT block */
/* (12) ILLEGAL block */
/* (13) %% */
/* (14) LEXFUNC block */
/* (15) YYWRAP block */

/* ( 1) %{ */
char *leftpar[] = {"%{", ""};
/* ( 2) YYSTYPE block */
char *yystype[] = {"#include \"gen.h\"", "extern YYSTYPE yylval;", ""};
/* ( 3) SETPOS block */
char *setpos[] = {
    "extern long yypos;",
    "#define yysetpos() { yylval.attr[0] = yypos; yypos += yyleng; }", ""};
/* ( 4) LITBLOCK block */
char *litblock[] = {""};
/* ( 5) %} */
char *rightpar[] = {"%}", ""};
/* ( 6) LEXDEF block */
char *lexdef[] = {""};
/* ( 7) %% */
char *separator[] = {"%%", ""};
/* ( 8) gen.lit */
/* ( 9) <token>.t for each <token> in gen.tkn */
/* (10) COMMENTS block */
char *comments[] = {""};
/* (11) LAYOUT block */
char *layout[] = {"\\  { yypos += 1; }", "\\n { yyPosToNextLine(); }",
                  "\\t { yypos += 1; }", ""};
/* (12) ILLEGAL block */
char *illegal[] = {". { yysetpos(); yyerror(\"illegal token\"); }", ""};
/* (14) LEXFUNC block */
char *lexfunc[] = {""};
/* (15) YYWRAP block */
char *yywrap[] = {"#ifndef yywrap", "yywrap() { return 1; }", "#endif", ""};

FILE *OUTFILE;

/**
 * This structure represents the parameters passed to the program.
 * It is in the form <Token>=<File.t>, where the extension must be
 * 't' and File is the user provided file, which will be stored in
 * replacement. The name of the token will be stored in name with extension '.t'
 *
 * This is in reality a linked list of info items.
 */
struct info {
  char *name; // the token file generated by gentle
  char *replacement; // the replacement file provided by the user
  int used; // whether it has been opened when copying to the gen.l file
  struct info *next; // The next parameter in the list
};

struct info *info_list = 0;

/*----------------------------------------------------------------------------*/
// These prototypes are necessary because the
// implementations are found after they are called
// The C compilers complain if they are not prototypes, but it compiles anyhow.
// Better to get rid of all the warnings and make the code cleaner.
// I think I will move these to separate include files and definition files.
void emit(char *text[]);
void copy(FILE *INFILE);
void copy_or_text(char *filename, char *text[]);
void filelist();

/*----------------------------------------------------------------------------*/
/**
 * This function is used to report errors and exit the application with
 * 1, meaning that it didn't terminate successfully.
 */
void err(char *fmt, char *a) {
  printf(fmt, a);
  exit(1);
}

/*----------------------------------------------------------------------------*/
/**
 * This function opens the file whose name is held in the name parameter.
 * The file will go through the info_list to search for the file in question,
 * and if it finds it in the info_list, or list provided by the user, it will
 * use the replacement instead. Otherwise, it will use the original one extracted
 * from the gen.tkn file.
 *
 * info_list is the list of parameters with a mapping of the token file to the
 * user defined one.
 */
FILE *OPEN(char *name) {
  FILE *F;
  struct info *cur;

  for (cur = info_list; cur; cur = cur->next) {
    if (strcmp(name, cur->name) == 0) {
      F = fopen(cur->replacement, "r");
      if (F == NULL)
        err("cannot open %s\n", cur->replacement);
      cur->used = 1;
      return F;
    }
  }
  F = fopen(name, "r");
  return F;
}

/*----------------------------------------------------------------------------*/

/**
 * This function handles all the arguments passed to the
 * application. It expects a list of arguments in the form
 * <Token>=<File.t>, where Token is the token included
 * in the file gen.tkn and File is the file where the
 * regular expressions for the Token are defined.
 *
 * It builds the sequence of arguments of type struct info
 * in the variable info_list. Info list holds the name of the token file,
 * and adds the replacement provided by the user. It is initialized with the
 * used field set to 0.
 */
void args(int argc, char **argv) {
  int i;

  struct info *new;

  // The code in this loop can be simplified
  // There is a lot clutter and some code
  // could be replaced by functions from
  // <string.h>
  for (i = 1; i < argc; i++) {
    int len, j, eq, dot;
    len = strlen(argv[i]);

    eq = -1;

    for (j = 0; j < len; j++) {
      if (argv[i][j] == '=') {
        eq = j;
        break;
      }
    }

    if (eq == -1)
      err("missing '=' in argument\n", "");

    dot = -1;

    for (j = len - 1; j > eq; j--) {
      if (argv[i][j] == '.') {
        dot = j;
        break;
      }
    }

    if (dot == -1)
      err("missing '.' in filename\n", "");

    new = (struct info *)malloc(sizeof(struct info));
    new->next = info_list;
    new->used = 0;
    info_list = new;

    new->name = (char *)malloc(eq + 2);
    strncpy(new->name, argv[i], eq);
    new->name[eq] = '.';
    new->name[eq + 1] = argv[i][len - 1];
    new->name[eq + 2] = '\0';

    new->replacement = (char *)malloc(len - eq - 1);
    strncpy(new->replacement, argv[i] + eq + 1, len - eq - 1);
    new->replacement[len - eq - 1] = '\0';
  }
}

/*----------------------------------------------------------------------------*/

int main(int argc, char **argv) {
  args(argc, argv);

  // open the target Flex file.
  OUTFILE = fopen("gen.l", "w");

  if (OUTFILE == NULL) {
    printf("cannot open gen.l\n");
    exit(1);
  }

  // generate the headers of the gen.l
  // file. They are either the default
  // provided by the strings at the beginning
  // of the file, or can be provided by the user
  // with the file names displayed in the first
  // parameter of function copy_or_text.
  /* ( 1) %{ */
  emit(leftpar);
  /* ( 2) YYSTYPE block */
  copy_or_text("YYSTYPE.b", yystype);
  /* ( 3) SETPOS block */
  copy_or_text("SETPOS.b", setpos);
  /* ( 4) LITBLOCK block */
  copy_or_text("LITBLOCK.b", litblock);
  /* ( 5) %} */
  emit(rightpar);
  /* ( 6) LEXDEF block */
  copy_or_text("LEXDEF.b", lexdef);
  /* ( 7) %% */
  emit(separator);
  /* ( 8) gen.lit */

  // The following block opens the gen.lit
  // file, with all the literals and copies
  // it verbatim to the gen.l file.
  {
    FILE *F;

    F = OPEN("gen.lit");
    if (F == NULL) {
      printf("cannot open gen.lit\n");
      exit(1);
    }
    copy(F);
  }

  /* ( 9) <token>.t for each <token> in gen.tkn */
  filelist();

  // In the following lines, the program will
  // add the comments, layout, illegal, lexfunc and
  // yywrap sections, which can be provided by the users
  // or used the default strings provided by the reflex program
  /* (10) COMMENTS block */
  copy_or_text("COMMENTS.b", comments);
  /* (11) LAYOUT block */
  copy_or_text("LAYOUT.b", layout);
  /* (12) ILLEGAL block */
  copy_or_text("ILLEGAL.b", illegal);
  /* (13) %% */
  emit(separator);
  /* (14) LEXFUNC block */
  copy_or_text("LEXFUNC.b", lexfunc);
  /* (15) YYWRAP block */
  copy_or_text("YYWRAP.b", yywrap);

  fclose(OUTFILE); // closes the output file

  // the following block will go through all
  // the arguments in the info_list and find
  // those that haven't been used. If they haven't
  // it will report an error saying that the
  // argument is invalid
  {
    struct info *cur;

    for (cur = info_list; cur; cur = cur->next) {
      cur->name[strlen(cur->name) - 2] = '\0';
      if (!cur->used)
        err("invalid argument %s\n", cur->name);
    }
  }
  return 0;
}

/*----------------------------------------------------------------------------*/
/**
 * This is a very simple function that just emits text found in arrays
 * to the gen.l file.
 *
 * I can be refactored so that it doesn't use a global file, but takes a
 * pointer to a file as parameter as well.
 */
void emit(char *text[]) {
  int i;

  for (i = 0; text[i][0]; i++)
    fprintf(OUTFILE, "%s\n", text[i]);
}

/*----------------------------------------------------------------------------*/

/**
 * This function copies the input file to the output file
 * or gen.l file.
 */
void copy(FILE *INFILE) {
  char prev = ' ';
  for (;;) {
    int ch = fgetc(INFILE);
    if (ch == EOF)
      break;
    prev = ch;
    fputc(ch, OUTFILE);
  }
  if (prev != '\n')
    fputc('\n', OUTFILE);
}

/*----------------------------------------------------------------------------*/

/**
 * This function checks if the filename provided in the first parameter
 * exists, and if it does, it opens it and copies it to the gen.l file.
 * Otherwise, it will copy the text passed in the second argument.
 * It relies on the copy function to copy the file to the gen.l file,
 * or the emit function to copy the text to the file.
 */
void copy_or_text(char *filename, char *text[]) {
  FILE *INFILE;

  INFILE = OPEN(filename);
  if (INFILE == NULL)
    emit(text);
  else {
    copy(INFILE);
    fclose(INFILE);
  }
}

/*----------------------------------------------------------------------------*/

/**
 * This function opens the gen.tkn file, where the list of tokens are provided
 * separated by the new line. For each token name, the function opens the file
 * <file>.t. It reports an error if the file is not found, and copies the
 * Token file to the gen.l file if it exists.
 */
void filelist() {
  FILE *LISTFILE;
  FILE *INFILE;

  LISTFILE = OPEN("gen.tkn");
  if (LISTFILE == NULL) {
    printf("cannot open gen.tkn\n");
    exit(1);
  }

  for (;;) {
    char name[500];
    char *p;
    int ch;

    ch = fgetc(LISTFILE);
    while (ch == '\n' || ch == ' ')
      ch = fgetc(LISTFILE);
    if (ch == EOF)
      break;

    p = &name[0];
    while (('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z') ||
           ('0' <= ch && ch <= '9') || ch == '_') {
      *p++ = ch;
      ch = fgetc(LISTFILE);
    }
    *p++ = '.';
    *p++ = 't';
    *p = '\0';

    INFILE = OPEN(name);
    if (INFILE == NULL) {
      printf("cannot open %s\n", name);
      exit(1);
    } else {
      copy(INFILE);
      fclose(INFILE);
    }
  }
  fclose(LISTFILE);
}

/*----------------------------------------------------------------------------*/
